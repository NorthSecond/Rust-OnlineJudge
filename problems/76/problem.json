{
    "title": "节点插入(线性表)",
    "description": "<p><span style=\"color: #323e32; font-size: 10.5pt\">有一个有序单链表（从小到大排序），表头指针为</span><span style=\"color: #323e32; font-size: 10.5pt\">head</span><span style=\"color: #323e32; font-size: 10.5pt\">，编写一个函数向该单链表中插入一个元素为</span><span style=\"color: #323e32; font-size: 10.5pt\">x</span><span style=\"color: #323e32; font-size: 10.5pt\">的结点，使插入后该链表仍然有序。</span><span style=\"color: #323e32; font-size: 10.5pt\"><br />\n<br />\n</span></p>",
    "input": "<p>输入长度n：5</p>\n<p>输入数据：1 6 8 9 10</p>\n<p>输入插入数据：7</p>",
    "output": "<p>输出：1 6 7 8 9 10</p>",
    "memory_limit": {
        "unit": "MB",
        "value": 128
    },
    "time_limit": {
        "unit": "s",
        "value": 1.0
    },
    "samples": [
        {
            "input": "4\n1 2 3 4\n6",
            "output": "1 2 3 4 6 "
        }
    ],
    "images": [],
    "append": [],
    "template": [],
    "prepend": [],
    "test_cases": [],
    "hint": null,
    "source": null,
    "spj": null,
    "solution": [
        {
            "language": "C",
            "code": "#include<stdio.h>\n#include<stdlib.h>\n#define ElemType int\ntypedef struct LNode{\n\tElemType data;\n\tstruct LNode *next;\n}LNode,*LinkList;\nvoid initial(LinkList L){\n\tint n;\n\tElemType data;\n\tLNode *p = L;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&data);\n\t\tLNode *s = (LNode *)malloc(sizeof(LNode));\n\t\ts->data = data;\n\t\tp->next = s;\n\t\tp = p->next;\n\t}\n\tp->next = NULL;\n}\nvoid insert(LinkList L,ElemType elem){\n\tLNode *p = L;\n\twhile(p->next){\n\t\tif(p->next->data>=elem){\n\t\t\tLNode *s = (LNode *)malloc(sizeof(LNode));\n\t\t\ts->data = elem;\n\t\t\ts->next = p->next;\n\t\t\tp->next = s;\n\t\t\treturn;\n\t\t}\n\t\tp = p->next;\n\t}\n\tLNode *s = (LNode *)malloc(sizeof(LNode));\n\ts->data = elem;\n\ts->next = p->next;\n\tp->next = s;\n}\n\nvoid print(LinkList L){\nint i=0;\n\tLNode *p;\n\tp = L->next;\n\twhile(p){\nif(i++)\nprintf(\" \");\n\t\tprintf(\"%d\",p->data);\n\t\tp = p->next;\n\t}\n}\nint main(){\n\tLinkList L = (LNode *)malloc(sizeof(LNode));\n\tElemType data;\n\tinitial(L);\n\tscanf(\"%d\",&data);\n\tinsert(L,data);\n\tprint(L);\n\treturn 0;\n}\n"
        },
        {
            "language": "C++",
            "code": "#include<iostream>\n\nusing namespace std;\n\nstruct Node\n{\n\tint data;\n\tNode* pNext;\n};\n\nstruct LinkList\n{\n\tNode* pHead;\n\tNode* pTail;\n};\n\nvoid createList(LinkList *list)\n{\n\tlist->pHead=(Node*)malloc(sizeof(Node));\n\tlist->pTail=list->pHead;\n\tlist->pTail->pNext=NULL;\n\t\n\tint n;\n\tcin>>n;\n\twhile(n--)\n\t{\n\t\tint val;\n\t\tcin>>val;\n\t\tNode* pNewNode;\n\t\tpNewNode=(Node*)malloc(sizeof(Node));\n\t\tpNewNode->data=val;\n\t\tlist->pTail->pNext=pNewNode;\n\t\tpNewNode->pNext=NULL;\n\t\tlist->pTail=pNewNode;\n\t}\n}\n\nvoid traverseList(LinkList *list)\n{\n\tNode* p=list->pHead->pNext;\n\tfor(;p!=NULL;p=p->pNext)\n\t\tcout<<p->data<<\" \";\n\tcout<<endl;\n}\n\nint main()\n{\n\tLinkList theList;\n\tcreateList(&theList);\n\t\n\tint val;\n\tcin>>val;\n\t\n\tfor(Node* p=theList.pHead->pNext;p!=NULL;p=p->pNext)\n\t{\n\t\tif(val==(p->data))\n\t\t{\n\t\t\tNode* q;\n\t\t\tq=(Node*)malloc(sizeof(Node));\n\t\t\tq->data=val;\n\t\t\tq->pNext=p->pNext;\n\t\t\tp->pNext=q;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tNode* p=theList.pHead->pNext;\n\tfor(;(p->pNext)!=NULL;p=p->pNext)\n\t{\n\t\tif(p->data<val&&(p->pNext->data)>val)\n\t\t{\n\t\t\tNode* q;\n\t\t\tq=(Node*)malloc(sizeof(Node));\n\t\t\tq->data=val;\n\t\t\tq->pNext=p->pNext;\n\t\t\tp->pNext=q;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(val<(theList.pHead->pNext->data))\n\t{\n\t\tNode* q;\n\t\tq=(Node*)malloc(sizeof(Node));\n\t\tq->data=val;\n\t\tq->pNext=theList.pHead->pNext;\n\t\ttheList.pHead->pNext=q;\n\t}\n\t\n\tif(val>(theList.pTail->data))\n\t{\n\t\n\t\tNode* q;\n\t\tq=(Node*)malloc(sizeof(Node));\n\t\tq->data=val;\n\t\ttheList.pTail->pNext=q;\n\t\tq->pNext=NULL;\n\t\ttheList.pTail=q;\n\n\t}\n\n\t\n\n\ttraverseList(&theList);\n\t//system(\"pause\");\n}"
        }
    ]
}