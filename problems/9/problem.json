{
    "title": "FBI树",
    "description": "我们可以把由“0”和“1”组成的字符串分为三类：全“0”串称为B串，全“1”串称为I串，既含“0”又含“1”的串则称为F串。<br />\n<p>\n\t<span style=\"line-height:1.5;\">FBI树是一种二叉树（如下图），它的结点类型也包括F结点，B结点和I结点三种。由一个长度为2N的“01”串S可以构造出一棵FBI树T，递归的构造方法如下：</span>\n</p>\n<p>\n\t1) T的根结点为R，其类型与串S的类型相同；\n</p>\n<p>\n\t2) 若串S的长度大于1，将串S从中间分开，分为等长的左右子串S1和S2；由左子串S1构造R的左子树T1，由右子串S2构造R的右子树T2。\n</p>\n现在给定一个长度为2N的“01”串，请用上述构造方法构造出一棵FBI树，并输出它的后序遍历序列。<br />\n<div>\n\t<br />\n</div>",
    "input": "<p>\n\t每组输入数据的第一行是一个整数N（0&lt;=N&lt;=10），第二行是一个长度为2N的“01”串。\n</p>\n<p>\n\t<br />\n</p>\n<p>\n\t数据规模：<br />\n对于40%的数据，N&lt;=2；<br />\n对于全部的数据，N&lt;=10。<br />\n\t<div>\n\t\t<br />\n\t</div>\n</p>",
    "output": "<p>\n\t每组输出包括一行，这一行只包含一个字符串，即FBI树的后序遍历序列。\n</p>\n<p>\n\t<br />\n</p>",
    "memory_limit": {
        "unit": "MB",
        "value": 125
    },
    "time_limit": {
        "unit": "s",
        "value": 1.0
    },
    "samples": [
        {
            "input": "3\n10001011",
            "output": "IBFBBBFIBFIIIFF"
        }
    ],
    "images": [],
    "append": [],
    "template": [],
    "prepend": [],
    "test_cases": [
        {
            "input": "9\n11000110111000000001110011110011011100011100010000110000110000000111010001010101000000111011001111100010000101101000011011111110010110000011001011011001011111100101000011011000001001001101100100011111001011000111111000110001000100111000010011101010000001101101011010101001011111100000110111001101110111110110111010100101001101001110110001100111000010000111001000100101001110111011101111100010001001100010000100110100100110010010000110101000101001100101001011011101110101111100000100111010110001001110001011001000\n",
            "output": "IIIBBBFBIFIBFFFIIIIBFFBBBBBBBFFBBBBIFFIIIBBBFFIIIIIIIBBBIIIFFFFBIFIIIFBBBBIFFFIIIBBBFBIFBBBFFFBBBIIIFBBBBBBBFIIIBBBFBBBBBBBFFFFBIFIIIFBIFBBBFFBIFBIFFBIFBIFFFFBBBBBBBBBBIIIFFIBFIIIFBBBIIIFFFFIIIIBFFBBBIBFFFBBBBIFFBIFIBFFFFIBFBBBFBIFIBFFFIIIIIIIIIIIBFFFFFFFBIFBIFFIBFBBBFFBBBIIIFBBBIBFFFFIIIBIFFIBFBIFFFBIFIIIFIIIIBFFFFFBIFBIFFBBBBBBBFIIIBIFFIBFBBBFFFBBBIBFFBIFBBBFFIIIBIFFIBFBIFFFFFFBBBBIFFIIIIIIIFBBBIBFFIIIBBBFFFBIFIIIFIIIIBFFFBBBIIIFBBBBIFFFFFBBBBIFFBBBIIIFFIBFBBBFBIFBBBFFFIIIIBFFIBFIBFFFBBBBBBBBIFIBFFFFFFFFIIIBIFFBIFIBFFFIBFIBFFIBFBIFFFFBIFIIIFIIIIBFFFBBBBBBBIIIBIFFFFFIIIBBBFIIIBIFFFIIIBIFFIIIIIIIFFBIFIBFFIIIIBFFFIBFIBFFBIFBIFFFFFFBBBIIIFBIFBBBFFIIIIBFFIIIBBBFFFBIFIBFFBIFIIIFFBBBBBBBIBFBBBFFFFBIFIIIFBBBIBFFFBBBIBFFBIFBIFFFFBBBIIIFIBFIIIFFIBFIIIFIBFIIIFFFFFFIIIIBFFBBBIBFFFBBBIBFFBIFIBFFFFBBBIBFFBBBBIFFFBBBIIIFBIFBBBFFFFIBFBIFFIBFBIFFFBBBIBFFBBBBIFFFFIBFIBFFIBFBBBFFIBFIBFFBIFIBFFFFFFBIFBIFFBBBIBFFFIIIBIFFIIIBIFFFFIIIBIFFBIFIIIFFIIIBBBFBBBBIFFFFFBBBIIIFIBFIBFFFIIIBBBFBIFBBBFFFIIIIBFFBBBIBFFFIIIBBBFIBFBBBFFFFFFFF\n"
        },
        {
            "input": "2\n1011\n",
            "output": "IBFIIIF\n"
        },
        {
            "input": "5\n10100100111010000000001011001100\n",
            "output": "IBFIBFFBIFBBBFFIIIIBFFIBFBBBFFFBBBBBBBBBBIBFFFIIIBBBFIIIBBBFFFF\n"
        },
        {
            "input": "2\n0101\n",
            "output": "BIFBIFF\n"
        },
        {
            "input": "6\n0110101101011001011110000100100101011011100111111010001000100100\n",
            "output": "BIFIBFFIBFIIIFFBIFBIFFIBFBIFFFFBIFIIIFIBFBBBFFBIFBBBFIBFBIFFFFFBIFBIFFIBFIIIFFIBFBIFFIIIIIIIFFIBFIBFFBBBIBFFFBBBIBFFBIFBBBFFFFF\n"
        },
        {
            "input": "3\n10001011\n",
            "output": "IBFBBBFIBFIIIFF\n"
        },
        {
            "input": "3\n11011000\n",
            "output": "IIIBIFFIBFBBBFF\n"
        },
        {
            "input": "0\n0\n",
            "output": "B\n"
        },
        {
            "input": "10\n1110001000011001011010111110110101001100101011001110010001010001110111111000111010011010110001100000010010001100000000101100110010110001110010101000011000011011110011000001010110111010100000001010010001101011000111010100011100000101100111111100011111001010100000000011001100010101111101001111111100000000000000111101110001111010011101011100110000111010111101000100110111110001000010101011110111011001100000010000010001100010010100111011101001000110010001010010110111001000110100001001001100011110111101001100010111100111111100110011101100101010011010101111010101111111100101101011101001101100000110110101001010000001000010010100110100110101000010000111100110011001111001001111110000111010001000100110100001110110000110100100101010101100010101111110001101001110011111100111111000001000000000001110010101101000100001001010000001001011100100000001101111000001110101011010100011111110111110011001110100101001010000100011110001001111111011101101110001110110111101001110010011001110000100111100010000001011001100000011001001000101\n",
            "output": "IIIIBFFBBBIBFFFBBBBIFFIBFBIFFFFBIFIBFFIBFIIIFFIIIIBFFIIIBIFFFFFBIFBBBFIIIBBBFFIBFIBFFIIIBBBFFFIIIIBFFBIFBBBFFBIFBIFFBBBBIFFFFFFIIIBIFFIIIIIIIFIBFBBBFIIIIBFFFFIBFBIFFIBFIBFFFIIIBBBFBIFIBFFFFFBBBBBBBBIFBBBFFIBFBBBFIIIBBBFFFBBBBBBBBBBIBFFFIIIBBBFIIIBBBFFFFFFIBFIIIFBBBBIFFFIIIBBBFIBFIBFFFFIBFBBBFBIFIBFFFBBBBIFFIBFIIIFFFFIIIBBBFIIIBBBFFBBBBIFFBIFBIFFFFIBFIIIFIBFIBFFFIBFBBBFBBBBBBBFFFFIBFIBFFBIFBBBFFBIFIBFFIBFIIIFFFBBBBIFFIIIBIFFFBIFBBBFBIFIIIFFFFBBBBBBBBIFBIFFFIBFBIFFIIIIIIIFFIIIBBBFBIFIIIFFIIIBBBFIBFIBFFFFFFFFIBFBBBFBBBBBBBFBBBIIIFBBBIIIFFFBBBBIFFBIFBIFFFIIIIIIIBIFBBBFFFFIIIIIIIIIIIIIIIBBBBBBBBBBBBBBBFBBBBBBBBBBIIIFFIIIBIFFIIIBBBFFFFFBIFIIIFIBFIBFFFBIFIIIFBIFBIFFFFIIIBBBFIIIBBBFFBBBIIIFIBFIBFFFFFIIIIIIIBIFBBBFFBIFBBBFIIIBIFFFFIIIIIIIBBBBIFFFBBBBBBBIBFIBFFFFFFFIBFIIIFIIIBIFFFIIIBIFFIBFBIFFFFIBFBBBFBBBBIFFFBBBBBBBBIFBBBFFFFBIFIBFFBBBIBFFFBIFBIFFBBBIIIFFFIBFIIIFIBFIBFFFBIFBBBFBIFIBFFFFFFBIFBBBFBIFBIFFFBBBIBFFIIIBIFFFFIIIBBBFIBFBBBFFIIIBIFFBBBBBBBFFFIBFBIFFBBBIIIFFBBBBIFFIIIIBFFFFIIIIIIIBIFBBBFFIIIBBBFBIFBIFFFFFFFFFIIIIBFFBIFIIIFFIIIIIIIBBBIIIFFFBBBIIIFIBFIIIFFBBBIBFFIBFIBFFFFFBIFIBFFIBFIBFFFIIIIIIIBIFBIFFFFBIFIIIFIIIIIIIFIBFBIFFBIFIBFFFFFFIBFIIIFIBFIBFFFBIFIBFFIIIBBBFFFBBBBIFFIBFIIIFFBIFBIFFBBBIBFFFFFIBFBBBFBBBBIFFFBBBBBBBIBFBIFFFFBIFBBBFIIIBIFFFBBBIIIFBIFBIFFFFFFFBBBBBBBIBFBBBFFBIFIIIFIBFBIFFFFIBFBIFFIBFBIFFFIIIIBFFBIFBBBFFFFIIIIIIIIIIBBBFFBBBIIIFIBFIBFFFFBBBIBFFBBBIBFFFBIFIBFFIBFBBBFFFFFBIFIIIFBIFIBFFFBBBBIFFIBFIBFFFFBIFBBBFIBFIBFFFIBFIBFFIIIBBBFFFFBIFBIFFBIFIIIFFIIIIBFFBBBIIIFFFBIFBBBFIIIIBFFFBIFIIIFIIIIBFFFFFFFFBIFIIIFIIIIBFFFBBBBBBBIBFBBBFFFBBBBBBBBBBBBBBBIIIIBFFBIFBIFFFFFBIFIBFFIBFBBBFFIBFBBBFBIFBBBFFFIBFIBFFBBBBBBBFBIFBBBFIBFIIIFFFFFIBFBIFFBBBBBBBFBBBBIFFIBFIIIFFFIIIBBBFBBBBIFFFIIIBIFFBIFBIFFFFFIBFIBFFIBFBBBFFIIIIIIIIIIIBFFFFIIIIIIIIBFBIFFFIBFBIFFIIIBIFFFFFFFBBBIBFFIBFBIFFFBIFBBBFBBBIBFFFFBBBIIIFIIIBBBFFBIFBBBFIIIIIIIFFFIIIIBFFIIIIBFFFIIIBIFFIIIBBBFFFBIFIIIFBIFIBFFFIIIIIIIBIFBBBFFFFFIIIIBFFBIFBBBFFIIIBBBFIIIIBFFFFBBBBIFFBBBIIIFFIIIBBBFBIFBBBFFFFBBBBBBBIBFIIIFFBBBIIIFBBBBBBBFFBBBIIIFBBBIBFFFBIFBBBFBIFBIFFFFFFFFFF\n"
        },
        {
            "input": "1\n10\n",
            "output": "IBF\n"
        }
    ],
    "hint": null,
    "source": "NOIP全国联赛普及组-2004年NOIP全国联赛普及组",
    "spj": null,
    "solution": [
        {
            "language": "C",
            "code": "#include <stdio.h>\n#include <math.h>\nstruct list\n{\n\tint left;\n\tint data;\n\tchar ch;\n   int right;\n\t};\nstruct list tree[2050];\n\nvoid print(int root)\n{\n\tif(root!=-1)\n\t  {\n\t\t  print(tree[root].left);\n\t\t  print(tree[root].right);\n\t\t  printf(\"%c\",tree[root].ch);\n\t\t  }\n\t}\nmain()\n{\n\t\n\tint i=1,n;\n\t//FILE *fin=fopen(\"fbi.in\",\"r\");\n\tscanf(\"%d\",&n);\n\tint front,len,node;\n\tfront=pow(2,n);\n\tlen=pow(2,n+1);\n\tnode=pow(2,n-1);\n\t  \n\t\n\t\n\tfor(i=front;i<len;i++)\n\t {\n\t\t scanf(\"%1d\",&tree[i].data);\n\t\t tree[i].left=-1;\n\t\t tree[i].right=-1;\n\t\t if(tree[i].data==1)\n\t\t   tree[i].ch='I';\n\t\t else\n\t\t   tree[i].ch='B';\n\t\t }\n\t\t/*for(i=1;i<len;i++)\n\t\t printf(\"%c \",tree[i].ch);\n\t\t printf(\"\\n\");*/\n    int temp=n-1;\n    while(temp>=0)\n      {\n\t      for(i=pow(2,temp);i<pow(2,temp+1);i++)\n\t        {\n\t\t        tree[i].left=2*i;\n\t\t        tree[i].right=2*i+1;\n\t\t        if(tree[2*i].ch=='B' && tree[2*i+1].ch=='B')\n\t\t        tree[i].ch='B';\n\t\t        else if(tree[2*i].ch=='I' && tree[2*i+1].ch=='I')\n\t\t        tree[i].ch='I';\n\t\t        else tree[i].ch='F';\n\t\t        }\n\t      temp--;\n\t      }\n\t   print(1);\n\t  \n\t}"
        },
        {
            "language": "C++",
            "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint m;\nchar str[3333];\nchar put[3] = {'B', 'I' ,'F'};\nint dfs(int sx,int ex)\n{\n    int a,b;\n    if(sx==ex)\n    {\n        printf(\"%c\", put[str[sx] - '0']);\n        return str[sx] - '0';\n    }\n    a=dfs(sx,(sx+ex)/2);\n    b=dfs((ex+sx)/2+1,ex);\n    if(a == b)\n        {\n        printf(\"%c\", put[a]);\n        return a;\n        }\n    else\n        {\n        cout<<'F';\n       return 2;\n       }\n}\nint main()\n{\n    scanf(\"%d\",&m);\n    scanf(\"%s\",str);\n    dfs(0,strlen(str)-1);\n    cout<<endl;\n    return 0;\n}\n"
        },
        {
            "language": "Pascal",
            "code": "var\n   n,i,j:longint;\n   s:ansistring;\n   a:array[0..100]of longint;\n   p:array[0..2050,0..2050]of char;\n   f:array[0..2050,0..2050]of boolean;\nprocedure dfs(t,x:longint);\nvar\n   i:longint;\nbegin\n if t>n+1 then exit;\n for i:=x to a[t] do\n  begin\n   if p[t,i]=' ' then exit;\n   if f[t,i] then continue;\n   write(p[t,i]);f[t,i]:=true;\n   if i mod 2=0 then\n    begin\n     if p[t,i]=p[t,i-1]then p[t+1,i div 2]:=p[t,i] else p[t+1,i div 2]:='F';\n     dfs(t+1,i div 2);\n    end;\n  end;\nend;\nbegin\n readln(n);\n a[n+1]:=1;\n for i:=n downto 1 do a[i]:=a[i+1]*2;\n for i:=1 to a[1] do\n  for j:=1 to n do p[j,i]:=' ';\n readln(s);\n for i:=1 to a[1] do\n  if s[i]='1' then p[1,i]:='I' else p[1,i]:='B';\n dfs(1,1);\nend."
        }
    ]
}